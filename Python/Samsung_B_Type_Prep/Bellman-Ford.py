# Bellman-Ford

# BOJ 11657 타임머신, BOJ 1865 웜홀, etc.

# Bellman-Ford 알고리즘은...
# 그래프에서 한 시작 노드로부터 모든 다른 노드까지의 최단 경로를 찾는 알고리즘
# Dijkstra, Floyd-Warshall 등의 최단거리 알고리즘들과 달리,
# 간선의 가중치가 음수일 때도 사용할 수 있다는 점이 차별점
# -> 알고리즘에서 음수 간선이 있으면 먼저 Bellman-Ford 의심해봐야한다!
# 만약 음의 가중치 사이클(negative cycle)이 존재하면
# 최단 경로가 무한히 작아지므로, 이를 감지할 수 있음!


# 기본 원리

# 1. 초기화
# 시작 노드 s의 거리 dist[s] = 0,
# 다른 모든 노드의 거리 dist[v] = INF (범위 밖 임의의 큰 수)

# 2. 간선 완화(Edge Relaxation)
# 각 간선 (u, v) 에 대해,
# 만약 dist[v] > dist[u] + cost(u,v) 라면 dist[v] 를 업데이트
# -> u를 거쳐 v로 가는 경로가 더 짧다

# 3. 반복
# 모든 간선을 V - 1 번 (V는 노드 수) 반복적으로 완화

# 4. 음의 사이클 체크
# V 번째 반복에서 여전히 완화가 일어나면 음의 사이클이 존재함을 의미 -> (최단 경로가 존재하지 않음)

# 시간 복잡도: O(V * E), V = 노드 수, E = 간선 수
# 그래프가 밀집(dense)하면 O(V^3)이 될 수 있지만,
# 일반적으로 효율적
# 저 O(V^3)이 될 수 있다는 점 때문에 실무적으로는 잘 안쓰인다 카더라...


# 간선완화 N번 하는 이유?
# 단순 경로에서 최단 경로는 V-1 개의 간선을 가짐
# -> 사이클이 없고, 노드를 반복 방문하지 않는다!
# -> 음수 사이클이 있는 경우는 문제있는거다!

# k번째 반복은 "최대 k개의 간선을 사용한 최단 경로"를 의미
# 1번째 반복: 시작 노드에서 직접 연결된 노드(1개 간선)만 업데이트
# 2번째 반복: 2개 간선 경로 고려 (이전 업데이트된 노드를 통해)
# ...
# N - 1 번째 반복: 최대 ( N - 1 ) 간선 경로를 모두 고려, 모든 가능한 최단 경로

# 각 반복에서 적어도 하나의 새로운 최단 경로가 업데이트됨으로
# N - 1 번 후 더 이상 업데이트 안 됨 (수렴)
# 만약 N - 1 번보다 적게 반복하면, 긴 경로(많은 간선)를 가진 최단 경로를 놓칠 수 있음

# 그리고 마지막에 1번 더 반복해서 음의 사이클 체크
# -> 마지막 반복에서도 여전히 업데이트가 일어난다면 음의 사이클이 있어 수렴이 불가능 함을 의미하므로


# 기본 코드

INF = float('inf')    # 범위 밖 임의의 큰 수


def bellman_ford(V, edges, start):    # V - 노드 갯수, edges - 간선 정보 리스트, start - 시작 노드
    dist = [INF] * V     # 거리 배열
    dist[start] = 0      # 시작 노드 거리 0으로 초기화

    # V - 1 번 간선 완화
    for _ in range(V - 1):
        updated = False
        for u, v, w in edges:    # 각 간선 시작 노드, 도착 노드, 코스트
            if dist[u] != INF and dist[v] > dist[u] + w:    # 더 짧은 거리 찾으면 업데이트
                dist[v] = dist[u] + w
                updated = True
        if not updated:  # 조기 종료 최적화
            break        # 업데이트가 일어나지 않았다 -> 이미 수렴했다

    # V 번째: 음의 사이클 체크
    for u, v, w in edges:
        if dist[u] != INF and dist[v] > dist[u] + w:    # 업데이트가 일어났다면
            return None  # 음의 사이클 존재
                         # 음의 사이클을 찾아야하는 문제 등이라면 Boolean 값을 return 해서
                         # is_cycle 등의 플래그를 만들어서 채크

    return dist          # 시작 노드로 부터 거리 배열 리턴


# 예시 그래프 (V=5, 노드 0~4)
edges = [
    (0, 1, 4), (0, 2, 2),
    (1, 2, 3), (1, 3, 2), (1, 4, 5),
    (3, 2, 1), (3, 4, 3),
    (4, 3, -3)  # 음의 간선
]

result = bellman_ford(5, edges, 0)
if result is None:
    print("음의 사이클 존재")
else:
    print("최단 거리:", result)

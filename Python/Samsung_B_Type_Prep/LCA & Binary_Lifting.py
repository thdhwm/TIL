# LCA (Lowest Common Ancestor) - 최소 공통 조상

# 트리에 있는 임의의 두 노드의 최소 공통 조상을 찾으려면 어떤 방법을 써야할까?

# 기본 아이디어
# 각 노드의 높이 (깊이, 레벨, 루트에서 부터 떨어진 길이, etc.) 정보를 저장해 놓고
# 공통 조상을 구할 2개의 노드 중 높이가 더 높은 쪽으로 높이를 통일
# 밑의 예시에서 4번과 3번의 공통 조상을 찾으려면
# 4의 높이는 2, 3의 높이는 1 이므로
# 4에서 1만큼 거슬러 올라가 4의 부모인 2를 찾고
# 2 와 3의 공통 조상을 찾는 문제와 동일
# 이제는 높이가 같아졌으니 각 노드에서 1칸씩 올라가면서
# 두 노드가 같은 노드를 부모로 가지고 있으면 LCA!

# 하지만 이렇게 1칸씩 올라가면 대량의 데이터에서 시간이 너무 오래 걸린다
# 그래서 시간을 줄이기 위해 Binary Lifting 을 도입한다
# Binary Lifting을 이용하면 1칸씩 ( O(N) ) 에서
# 2^k 씩 올라가서 ( O(log N) )  으로 시간 단축!

# Binary Lifting 이란?
# 1칸씩 올라가는 대신 2^k 칸 점프 해서 트리를 타고 올라가는 것
# 이를 위해 미리 부모 배열을 만들어놓고 점프할 때 부모 배열에서 찾아서 점프
# 부모 배열은 Parent[k][v] 형식으로 저장
# k 는 v 로 부터 2^k 만큼 떨어진 부모 라는 뜻
# ex. 밑의 예시 에서 Parent[1][4] 는 '4' 노드에서 2^1 만큼 즉, 2만큼 떨어진 부모
# 그것은 바로 '1' !
# Parent[1][4] = 1 이라는 것이다

# 왜 하필 2^k 점프하는가?
# 1개씩 다 보면 시간이 너무 많이 걸리니 시간을 줄이기 위해 점프하면서 보겠다는 목적에서
# 2^k 점프가 아니여도 상관은 없다!!  ( 3^k, 5^k 다 구현만 할수 있음 해봐라...? (어렵다함) )
# 하지만, 컴퓨터에서 2진수가 연산에 이점이 많다 -> 비트 연산 가능!
# 예시로 13번 점프를 해야 2개의 노드의 높이를 맞출 수 있다고 가정하면
# 13 = 1101(2) 이므로 8 점프 + 4점프 + 1점프 로 비트 연산이 가능

# 점프하다가 목표 노드를 넘어가면 어캄?
# 목표 노드를 넘어간다 -> 두 노드가 점프한 결과가 같다
# 그럼 점프 하지 말고 k 줄여서 다시 점프, 반복
# 그럼 최종적으로 LCA 직전 자식들이 구해짐,
# 그래서 parent[0][node]가 LCA !


# 기본 예시 코드
import math

# 입력 설정 (예시 트리)
N = 7  # 노드 수
tree = [[] for _ in range(N + 1)]  # 인접 리스트
tree[1] = [2, 3]      #                  1   (root, 높이 0)
tree[2] = [1, 4, 5]   #               /     \
tree[3] = [1, 6, 7]   #              2       3   ( 높이 1 )
tree[4] = [2]         #            /   \   /   \
tree[5] = [2]         #           4     5 6     7   ( 높이 2 )
tree[6] = [3]
tree[7] = [3]

# Preprocessing 준비
LOG = int(math.log2(N)) + 1  # log N -> 트리의 높이 대략적으로
# math 안 쓸거면 입력 범위 봐서 2^m 구해서 하면 됨!

parent = [[0] * (N + 1) for _ in range(LOG)]  # parent[k][v]: v의 2^k 부모
depth = [0] * (N + 1)  # 높이


# DFS로 깊이와 parent[0] (직계 부모) 채우기
def dfs(node, par, dep):
    parent[0][node] = par          # 직계 부모 구함
    depth[node] = dep              # 자기의 높이 저장
    for child in tree[node]:       # 자식 노드 보기
        if child != par:           # 부모 노드 빼고 나머지가 자식이니까
            dfs(child, node, dep + 1)     # 자식에 대해서도 dfs 수행


dfs(1, 0, 0)  # root 노드인 1부터 시작

# 2^k 부모 테이블 채우기 (2^k 점프 과정)
for k in range(1, LOG):          # 각 높이 만큼에서
    for v in range(1, N + 1):    # 모든 노드에 대하여
        if parent[k - 1][v] != 0:    # 위에서 직계 부모 구해놨으니까 직계 부모는 0 말고 다른거로 되있겠지?
            parent[k][v] = parent[k - 1][parent[k - 1][v]]    # 2^k = 2^(k-1) * 2  ->  2^(k-1) 만큼 2번 뛴 것과 같다


# LCA 쿼리 함수 ( u, v 의 공통 조상은 뭐임? 하고 물어보는 함수 )
def lca(u, v):
    if depth[u] > depth[v]:    # 두 노드의 높이 맞추기
        u, v = v, u                # u가 더 낮게 통일
    diff = depth[v] - depth[u]   # 두 노드의 높이 차이
    k = 0                       # 2^k 점프 할 때 그 k
    while diff:
        if diff % 2:  # diff의 k번째 비트가 1이면 2^k 점프 -> ex. 에서 13 = 1101(2) 이고 이러면 8, 4, 1 점프
            v = parent[k][v]    # 점프한 노드로 바꿔주기
        diff //= 2    # 비트 연산으로 점프한거 빼기 -> ex. 에서 13 = 1101(2) 일때 점프 했으면 110(2) 가 되는 것
        k += 1        # 2^k 점프 할 때 그 k

    if u == v:    # u와 v가 같으면 return
        return u

    for k in range(LOG - 1, -1, -1):    # 공통 조상 찾기 (큰 k부터, Greedy 적으로)
        if parent[k][u] != parent[k][v]:    # 2^k 부모가 다르면 둘 다 2^k 점프
            u = parent[k][u]       # 점프한 노드로 바꿔주기
            v = parent[k][v]       # 점프한 노드로 바꿔주기

    return parent[0][u]    # 직계 부모가 LCA


# 예시
print(lca(4, 5))  # 출력: 2 (4와 5의 LCA는 2)
print(lca(4, 6))  # 출력: 1 (4와 6의 LCA는 1)
print(lca(2, 3))  # 출력: 1